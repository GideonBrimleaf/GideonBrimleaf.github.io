---
layout: post
title: Adventures in Ruby - Self vs @
author: Gideon Brimleaf
postHero: /assets/images/traveller.jpeg
---

Ever had that moment when someone asks you a deceptively simple question which, the
more you think about it, gets harder and harder to answer?  So I had that last night with
this seemingly innocuous bit of code in my Rails app:

<pre class="p-2 bg-primary text-light">
class Order < ApplicationRecord

  def process!
      self.processed = true
      self.processed_at = Time.now.utc
  end

end
</pre>

That's a lot of selfs.  This method, as we can see, is in the Order class, which inherits
from ApplicationRecord, and it's updating some values  on the order instance of our class. 

So the question that came to mind was why do we need self here? As we're in our class why 
can't we just refer to the instance variables like so:

<pre class="p-2 bg-primary text-light">
class Order < ApplicationRecord

  def process!
      @processed = true
      @processed_at = Time.now.utc
  end

end
</pre>

This caused some head scratches as all my tests started to fail.  After lots of playing around
I realised the subtle (but very important) difference in the change:

1. <em>"@instance_variable = x"</em> is assigning the @instance_variable with the value x
2. <em>self.instance_variable = x</em> is calling the method 'instance_variable=' and passing in 
x as the argument

In straight-up Ruby, self.instance_variable is normally something that you need to use if you're
triggering a getter or a setter method which will be returning the instance variable under the hood 
like so:

<pre class="p-2 bg-primary text-light">
  def name
    @name
  end

  def name=(n)
    @name = n
  end
</pre>

If retriving or changing the variable is the only thing we we expect to do then this is often condensed 
to:

<pre class="p-2 bg-primary text-light">
  attr_accessor :name
</pre>

However we could be doing other things as well in that getter or setter method like logging that the
instance variable is updated or udating a value in the database. This detail is very important when it 
comes to Active Record models, as our class instances have the following:

1. Variables which map to values in the database for that instance
2. Variables which are just held in memory on that instance

In Rails, both types of variables are dealt with in the same way, by generating getter/setter 
methods which we can call with self.instance_variable. So we don't need to worry if our variable is 
a database value that needs to be updated or just an ephemeral instance variable just required in 
memory, the trigger is the same. 

<pre class="p-2 bg-primary text-light">
      self.processed = true
</pre>

If processed is just an instance variable in memory then it'll be updated, if it's a database 
value then that will also be updated. However if we just did 

<pre class="p-2 bg-primary text-light">
      @processed = true
</pre>

This will just update an instance variable in memory called @processed to true. This won't change 
anything in the database.

So self.instance_variable= is a method invocation, @instance_variable= is an assignment!  This also has
implications for straight up ruby applications as well - if you're wanting to do more than just assign 
a value to a variable with a getter or setter then you would need your own methods that you would invoke
with self.
